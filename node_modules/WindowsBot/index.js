const net = require('net');
const child_process = require('child_process');
const restler = require('restler');//验证码依赖
const fs = require('fs');
const path = require("path");

class WindowsBot{
    static server;
    /**
    * @param {function(WindowsBot)} windowsMain 要注册的函数，必须含一个参数，用作接收WindowsBot对象
    * @param {string} ip 脚本所在的地址，传递给WindowsDriver.exe。如果值为 "127.0.0.1"脚本会将参数 ip和port作为启动参数并启动WindowsDriver.exe，否则用户需要手动启动WindowsDriver.exe 并且提供启动参数。
    * @param {number} port 监听端口, 传递给WindowsDriver.exe
    */
    static registerMain(windowsMain, ip, port = 26678){
        //本地ip由脚本服务端启动驱动程序
        if(ip == "127.0.0.1"){
            //获取驱动程序路径
            let driverPath = path.resolve(__dirname, "../../../WindowsDriver.exe");
            let isExist = fs.existsSync(driverPath);
            if(!isExist)
                driverPath = 'WindowsDriver.exe';

            child_process.execFile(driverPath, [ip, port]);
            console.log("正在启动WindowsDriver...");
        }

        WindowsBot.server = new net.createServer();
        WindowsBot.server.listen(port);
        WindowsBot.server.on('connection', (clientSocket) => {
            windowsMain(new WindowsBot(clientSocket));
        });
    }

    socket;
    resolveHand;
    recvData;
    recvDataLen;
    isFirstData;
    waitTimeout;
    intervalTimeout;
    mutex;
    constructor(clientSocket) {
        this.socket = clientSocket;
        this.resolveHand = null;
        this.recvData = "";
        this.isFirstData = true;//标记write首次触发data事件
        this.waitTimeout = 0;//隐式等待超时
        this.intervalTimeout = 1;//每次等待的时间
        this.mutex = new Mutex();

        this.socket.on('connect', ()=>{
            this.resolveHand(this);//返回WindowsBot
        });
        
        this.socket.on('error', error=>{
            console.log(error);
        });
        
        this.socket.on('close', ()=>{
            console.log('WindowsBot已关闭');
        });

        this.socket.on('data', data => {
            if(this.isFirstData){
                this.isFirstData = false;
                let strData = data.toString();
                let index = strData.indexOf("/");
                this.recvDataLen = parseInt(strData.substring(0, index), 10);
                //重新赋值
                this.recvData = data.slice(index + 1);
            }else{
                this.recvData = Buffer.concat([this.recvData, data]);
            }

            if (this.resolveHand && this.recvDataLen == this.recvData.length) {
                //清理现场
                this.isFirstData = true;
                this.resolveHand(this.recvData);
                this.resolveHand = null;
                this.mutex.release();//释放锁
            }
        });
    }

    static sleep(millisecond){
        return new Promise(resolve => {setTimeout(() => {resolve()}, millisecond)});
    }

    /**构建windowsBot
     * @param {string} ip windowsBot服务端地址，假如值为 "127.0.0.1"脚本会自动启动WindowsDriver.exe，如果是远程服务地址，用户需要手动启动WindowsDriver.exe 并且提供启动参数。
     * 命令行启动示例：WindowsDriver.exe 19999
     * @param {number} port windowsBot服务端端口, 默认 19999
     * @return {Promise.<WindowsBot>}
    */
    static async build(ip, port = 19999){
        if(ip == "127.0.0.1"){
            //获取驱动程序路径
            let driverPath = path.resolve(__dirname, "../../../WindowsDriver.exe");
            let isExist = await fs.existsSync(driverPath);
            if(!isExist)
                driverPath = 'WindowsDriver.exe';

            child_process.execFile(driverPath, [port]);
            console.log("正在启动WindowsDriver...");
            await this.sleep(3000);
        }
        return new Promise((resolve) => {
            new WindowsBot(ip, port, resolve);
        });
    }

    setSendData = (...arrArgs) =>{
        // len/len/len\ndata
        let strData = "";
        let tempStr = "";
        arrArgs.forEach((args) =>{
          if(args == null)
            args = "";
          tempStr += args;
          strData += Buffer.byteLength(args.toString(), "utf8");//获取包含中文实际长度
          strData += '/';
        });
        strData += '\n';
        strData += tempStr;
        return strData;
    }

    /**发送数据
    * @param {string} strData
    * @return {string}
    */
    sendData = (strData)=>{
        return new Promise(async (resolve) => {
            await this.mutex.lock();//加队列锁，防止数据并发
            this.resolveHand = resolve;
            this.socket.write(strData);
        })
    }

    /**睡眠等待
     * @param {number} millisecond  等待时间,单位毫秒
     * @return {Promise.<void>}
    */
    async sleep(millisecond){
        return new Promise(resolve => {setTimeout(() => {resolve()}, millisecond)});
    }

    /**设置隐式等待
     * @param {number} waitMs  等待时间,单位毫秒
     * @param {number} intervalMs 心跳间隔，单位毫秒。可选参数，默认10毫秒
     * @return {Promise.<void>}
    */
    async setImplicitTimeout(waitMs, intervalMs = 10){
        this.waitTimeout = waitMs;
        this.intervalTimeout = intervalMs;
    }

    /**查找窗口句柄
     * @param {string} className  窗口类名
     * @param {string} windowNmae 窗口名
     * @return {Promise.<string>} 成功返回窗口句柄，失败返回null
    */
    async findWindow(className, windowNmae){
        let strData = this.setSendData("findWindow", className, windowNmae);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**查找窗口句柄数组
     * @param {string} className  窗口类名
     * @param {string} windowNmae 窗口名
     * @return {Promise.<[]>} 成功返回窗口句柄数组，失败返回null
    */
    async findWindows(className, windowNmae){
        let strData = this.setSendData("findWindows", className, windowNmae);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet.split("|");
    }

    /**查找子窗口句柄
     * @param {string|number} curHwnd  当前窗口句柄
     * @param {string} className  窗口类名
     * @param {string} windowNmae 窗口名
     * @return {Promise.<string>} 成功返回窗口句柄，失败返回null
    */
    async findSubWindow(curHwnd, className, windowNmae){
        let strData = this.setSendData("findSubWindow", curHwnd, className, windowNmae);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**查找父窗口句柄
     * @param {string|number} curHwnd  当前窗口句柄
     * @return {Promise.<string>} 成功返回窗口句柄，失败返回null
    */
    async findParentWindow(curHwnd){
        let strData = this.setSendData("findParentWindow", curHwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**查找桌面窗口句柄
     * @return {Promise.<string>} 成功返回窗口句柄，失败返回null
    */
    async findDesktopWindow(){
        let strData = this.setSendData("findDesktopWindow");
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**获取窗口名称
     * @param {string|number} hwnd 窗口句柄
     * @return {Promise.<string>} 成功返回窗口名称，失败返回null
    */
    async getWindowName(hwnd){
        let strData = this.setSendData("getWindowName", hwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**显示/隐藏窗口
     * @param {string|number} hwnd 窗口句柄
     * @param {boolean} isShow 显示窗口 true， 隐藏窗口 false
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
     async showWindow(hwnd, isShow){
        let strData = this.setSendData("showWindow", hwnd, isShow);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置窗口到最顶层
     * @param {string|number} hwnd 窗口句柄
     * @param {boolean} isTop 是否置顶，true置顶， false取消置顶
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async setWindowTop(hwnd, isTop){
        let strData = this.setSendData("setWindowTop", hwnd, isTop);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**获取窗口位置
     * @param {string|number} hwnd  窗口句柄
     * @return {Promise.<{left:number, top:number, width:number, height:number}>} 成功返回窗口位置，失败返回null
    */
    async getWindowPos(hwnd){
        let strData = this.setSendData('getWindowPos', hwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "-1|-1|-1|-1")
            return null;
        let arrRet = strRet.split("|");
        return {left: parseInt(arrRet[0]), top: parseInt(arrRet[1]), width: parseInt(arrRet[2]), height: parseInt(arrRet[3])};
    }

    /**设置窗口位置
     * @param {string|number} hwnd  窗口句柄
     * @param {number} left 左上角横坐标
     * @param {number} top 左上角纵坐标
     * @param {number} width 窗口宽度
     * @param {number} height 窗口高度
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setWindowPos(hwnd, left, top, width, height){
        let strData = this.setSendData('setWindowPos', hwnd, left, top, width, height);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**移动鼠标
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x  横坐标
     * @param {number} y  纵坐标
     * @param {{mode:boolean, elementHwnd:string|number}} options 操作模式，后台 true，前台 false。默认前台操作。
     * 如果mode值为true且目标控件有单独的句柄，则需要通过getElementWindow获得元素句柄，指定elementHwnd的值(极少应用窗口由父窗口响应消息，则无需指定)
     * @return {Promise.<boolean>} 总是返回true
    */
    async moveMouse(hwnd, x, y, options = {}){
        let mode = false;
        let elementHwnd = 0;
        if(options["mode"] != undefined)
            mode = options["mode"];
        if(options["elementHwnd"] != undefined)
            elementHwnd = options["elementHwnd"];

        let strData = this.setSendData("moveMouse", hwnd, x, y, mode, elementHwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**移动鼠标(相对坐标)
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x  相对横坐标
     * @param {number} y  相对纵坐标
     * @param {boolean} mode  操作模式，后台 true，前台 false。默认前台操作
     * @return {Promise.<boolean>} 总是返回true
    */
    async moveMouseRelative(hwnd, x, y, mode = false){
        let strData = this.setSendData("moveMouseRelative", hwnd, x, y, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**滚动鼠标
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x  横坐标
     * @param {number} y  纵坐标
     * @param {number} dwData 鼠标滚动次数,负数下滚鼠标,正数上滚鼠标
     * @param {boolean} mode  操作模式，后台 true，前台 false。默认前台操作
     * @return {Promise.<boolean>} 总是返回true
    */
    async rollMouse(hwnd, x, y, dwData, mode = false){
        let strData = this.setSendData("rollMouse", hwnd, x, y, dwData, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**鼠标点击
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x  横坐标
     * @param {number} y  纵坐标
     * @param {number} msg 单击左键:1 单击右键:2 按下左键:3 弹起左键:4 按下右键:5 弹起右键:6 双击左键:7 双击右键:8
     * @param {{mode:boolean, elementHwnd:string|number}} options 操作模式，后台 true，前台 false。默认前台操作。
     * 如果mode值为true且目标控件有单独的句柄，则需要通过getElementWindow获得元素句柄，指定elementHwnd的值(极少应用窗口由父窗口响应消息，则无需指定)
     * @return {Promise.<boolean>} 总是返回true。
    */
    async clickMouse(hwnd, x, y, msg, options = {}){
        let mode = false;
        let elementHwnd = 0;
        if(options["mode"] != undefined)
            mode = options["mode"];
        if(options["elementHwnd"] != undefined)
            elementHwnd = options["elementHwnd"];

        let strData = this.setSendData("clickMouse", hwnd, x, y, msg, mode, elementHwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**输入文本
     * @param {string} text  输入的文本
     * @return {Promise.<boolean>} 总是返回true
    */
    async sendKeys(text){
        let strData = this.setSendData("sendKeys", text);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**后台输入文本
     * @param {string|number} hwnd 窗口句柄，如果目标控件有单独的句柄，需要通过getElementWindow获得句柄
     * @param {string} text  输入的文本
     * @return {Promise.<boolean>} 总是返回true
    */
     async sendKeysByHwnd(hwnd, text){
        let strData = this.setSendData("sendKeysByHwnd", hwnd, text);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**输入虚拟键值(VK)
     * @param {number} bVk VK键值，例如：回车对应 VK键值 13
     * @param {number} msg 按下弹起:1 按下:2 弹起:3
     * @return {Promise.<boolean>} 总是返回true
    */
    async sendVk(bVk, msg){
        let strData = this.setSendData("sendVk", bVk, msg);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**后台输入虚拟键值(VK)
     * @param {string|number} hwnd  窗口句柄，如果目标控件有单独的句柄，需要通过getElementWindow获得句柄
     * @param {number} bVk VK键值，例如：回车对应 VK键值 13
     * @param {number} msg 按下弹起:1 按下:2 弹起:3
     * @return {Promise.<boolean>} 总是返回true。若是后台组合键，可使用sendVk 按下控制键(Alt、Shift、Ctrl...)，再组合其他按键
    */
    async sendVkByHwnd(hwnd, bVk, msg){
        let strData = this.setSendData("sendVkByHwnd", hwnd, bVk, msg);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**截图保存
     * @param {string|number} hwnd  窗口句柄
     * @param {string} savePath 保存的位置
     * @param {{region:[left:number, top:number, right:number, bottom:number], threshold:[thresholdType:number, thresh:number, maxval:number], mode:boolean}} options 可选参数
     * region截图区域 [10, 20, 100, 200]，region默认  hwnd对应的窗口
     * threshold二值化图片, thresholdType算法类型：
                                                0   THRESH_BINARY算法，当前点值大于阈值thresh时，取最大值maxva，否则设置为0
                                                1   THRESH_BINARY_INV算法，当前点值大于阈值thresh时，设置为0，否则设置为最大值maxva
                                                2   THRESH_TOZERO算法，当前点值大于阈值thresh时，不改变，否则设置为0
                                                3   THRESH_TOZERO_INV算法，当前点值大于阈值thresh时，设置为0，否则不改变
                                                4   THRESH_TRUNC算法，当前点值大于阈值thresh时，设置为阈值thresh，否则不改变
                                                5   ADAPTIVE_THRESH_MEAN_C算法，自适应阈值
                                                6   ADAPTIVE_THRESH_GAUSSIAN_C算法，自适应阈值
                                                thresh阈值，maxval最大值，threshold默认保存原图。thresh和maxval同为255时灰度处理
    * mode操作模式，后台 true，前台 false。默认前台操作       
     * @return {Promise.<boolean>}
    */
    async saveScreenshot(hwnd, savePath, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        let thresholdType = 0, thresh = 0, maxval = 0;
        let mode = false;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }
        if(options["threshold"] != undefined){
            thresholdType = options["threshold"][0];
            if(thresholdType == 5 || thresholdType == 6){
                thresh = 127;
                maxval = 255;
            }else{
                thresh = options["threshold"][1];
                maxval = options["threshold"][2];
            }
        }
        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData = this.setSendData("saveScreenshot", hwnd, savePath, left, top, right, bottom, thresholdType, thresh, maxval, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**获取指定坐标点的色值
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x 横坐标
     * @param {number} y 纵坐标 
     * @param {boolean} mode 操作模式，后台 true，前台 false。默认前台操作
     * @return {Promise.<string>} 成功返回#开头的颜色值，失败返回null
    */
    async getColor(hwnd, x, y, mode = false){
        let strData = this.setSendData("getColor", hwnd, x, y, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**找图
     * @param {string|number} hwnd  窗口句柄
     * @param {string} imagePath 小图片路径
     * @param {{region:[left:number, top:number, right:number, bottom:number], sim:number, threshold:[thresholdType:number, thresh:number, maxval:number], multi:number, mode:boolean}} options 可选参数
     * region 指定区域找图 [10, 20, 100, 200]，region默认 hwnd对应的窗口
     * sim浮点型 图片相似度 0.0-1.0，sim默认0.95 
     * threshold二值化图片, thresholdType算法类型：
                                                0   THRESH_BINARY算法，当前点值大于阈值thresh时，取最大值maxva，否则设置为0
                                                1   THRESH_BINARY_INV算法，当前点值大于阈值thresh时，设置为0，否则设置为最大值maxva
                                                2   THRESH_TOZERO算法，当前点值大于阈值thresh时，不改变，否则设置为0
                                                3   THRESH_TOZERO_INV算法，当前点值大于阈值thresh时，设置为0，否则不改变
                                                4   THRESH_TRUNC算法，当前点值大于阈值thresh时，设置为阈值thresh，否则不改变
                                                5   ADAPTIVE_THRESH_MEAN_C算法，自适应阈值
                                                6   ADAPTIVE_THRESH_GAUSSIAN_C算法，自适应阈值
                                                thresh阈值，maxval最大值，threshold默认保存原图。thresh和maxval同为255时灰度处理
     * multi 找图数量，默认为1 找单个图片坐标
     * mode 操作模式，后台 true，前台 false。默认前台操作   
     * @return {Promise.<[{x:number, y:number}]>} 成功返回 单坐标点[{x:number, y:number}]，多坐标点[{x1:number, y1:number}, {x2:number, y2:number}...] 失败返回null
    */
    async findImage(hwnd, imagePath, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        let sim = 0.95;
        let thresholdType = 0, thresh = 0, maxval = 0;
        let multi = 1;
        let mode = false;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }
        if(options["sim"] != undefined)
            sim = options["sim"];
        if(options["threshold"] != undefined){
            thresholdType = options["threshold"][0];
            if(thresholdType == 5 || thresholdType == 6){
                thresh = 127;
                maxval = 255;
            }else{
                thresh = options["threshold"][1];
                maxval = options["threshold"][2];
            }
        }
        if(options["multi"] != undefined)
            multi = options["multi"];

        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData = this.setSendData("findImage", hwnd, imagePath, left, top, right, bottom, sim, thresholdType, thresh, maxval, multi, mode);
        let strRet, byteRet;
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "-1|-1")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "-1|-1")
            return null;

        let arrPoints = strRet.split("/");
        let pointCount = arrPoints.length;
        let arrRet = [];
        let arrPoint;
        for(let i = 0; i < pointCount; i++){
            arrPoint = arrPoints[i].split("|");
            arrRet[i] = {x: parseInt(arrPoint[0]), y: parseInt(arrPoint[1])};
        }
        return arrRet;
    }

    /**找动态图
     * @param {string|number} hwnd  窗口句柄
     * @param {number} frameRate 前后两张图相隔的时间，单位毫秒
     * @param {{region:[left:number, top:number, right:number, bottom:number], mode:boolean}} options 可选参数
     * region 指定区域找图 [10, 20, 100, 200]，region默认 hwnd对应的窗口
     * mode 操作模式，后台 true，前台 false。默认前台操作   
     * @return {Promise.<[{x:number, y:number}]>} 成功返回 单坐标点[{x:number, y:number}]，多坐标点[{x1:number, y1:number}, {x2:number, y2:number}...] 失败返回null
    */
    async findAnimation(hwnd, frameRate, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        let mode = false;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }

        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData = this.setSendData("findAnimation", hwnd, frameRate, left, top, right, bottom, mode);
        let strRet, byteRet;
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "-1|-1")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "-1|-1")
            return null;

        let arrPoints = strRet.split("/");
        let pointCount = arrPoints.length;
        let arrRet = [];
        let arrPoint;
        for(let i = 0; i < pointCount; i++){
            arrPoint = arrPoints[i].split("|");
            arrRet[i] = {x: parseInt(arrPoint[0]), y: parseInt(arrPoint[1])};
        }
        return arrRet;
    }

    /**查找指定色值的坐标点
     * @param {string|number} hwnd  窗口句柄
     * @param {string} strMainColor #开头的色值
     * @param {{subColors:[[offsetX:number, offsetY:number, strSubColor:string], ...], region:[left:number, top:number, right:number, bottom:number], sim:number, mode:boolean}} options 可选参数
     * subColors 相对于strMainColor 的子色值，[[offsetX, offsetY, "#FFFFFF"], ...]，subColors默认为null
     * region 指定区域找色 [10, 20, 100, 200]，region默认 hwnd对应的窗口
     * sim相似度0.0-1.0，sim默认为1
     * mode 操作模式，后台 true，前台 false。默认前台操作   
     * @return {Promise.<{x:number, y:number}>} 成功返回{x:number, y:number} 失败返回null
    */
    async findColor(hwnd, strMainColor, options = {}){
        let strSubColors = "null";
        let left = 0, top = 0, right = 0, bottom = 0;
        let sim = 1;
        let mode = false;
        if(options["subColors"] != undefined){
            strSubColors = "";
            let arrLen = options["subColors"].length;
            for(let i = 0; i < arrLen; i++){
                strSubColors += options["subColors"][i][0] + "/";
                strSubColors += options["subColors"][i][1] + "/";
                strSubColors += options["subColors"][i][2];
                if(i < arrLen - 1)
                    strSubColors += "\n";
            }
        }
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }
        if(options["sim"] != undefined)
            sim = options["sim"];
        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData = this.setSendData("findColor", hwnd, strMainColor, strSubColors, left, top, right, bottom, sim, mode);
        let strRet, byteRet;
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "-1|-1")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "-1|-1")
            return null;
        let arrRet = strRet.split("|");
        return {x: parseInt(arrRet[0]), y: parseInt(arrRet[1])};
    }

    /**比较指定坐标点的颜色值
     * @param {string|number} hwnd  窗口句柄
     * @param {number} mainX 主颜色所在的X坐标
     * @param {number} mainY 主颜色所在的Y坐标
     * @param {string} strMainColor #开头的色值
     * @param {{subColors:[[offsetX:number, offsetY:number, strSubColor:string], ...], region:[left:number, top:number, right:number, bottom:number], sim:number, mode:boolean}} options 可选参数
     * subColors 相对于strMainColor 的子色值，[[offsetX, offsetY, "#FFFFFF"], ...]，subColors默认为null
     * region 指定区域找色 [10, 20, 100, 200]，region默认 hwnd对应的窗口
     * sim相似度0.0-1.0，sim默认为1
     * mode 操作模式，后台 true，前台 false。默认前台操作   
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async compareColor(hwnd, mainX, mainY, strMainColor, options = {}){
        let strSubColors = "null";
        let left = 0, top = 0, right = 0, bottom = 0;
        let sim = 1;
        let mode = false;
        if(options["subColors"] != undefined){
            strSubColors = "";
            let arrLen = options["subColors"].length;
            for(let i = 0; i < arrLen; i++){
                strSubColors += options["subColors"][i][0] + "/";
                strSubColors += options["subColors"][i][1] + "/";
                strSubColors += options["subColors"][i][2];
                if(i < arrLen - 1)
                    strSubColors += "\n";
            }
        }
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }
        if(options["sim"] != undefined)
            sim = options["sim"];
        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData = this.setSendData("compareColor", hwnd, mainX, mainY, strMainColor, strSubColors, left, top, right, bottom, sim, mode);
        let strRet, byteRet;
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "false")
            return false;
        else
            return true;
    }

    //解析ocr
    splitOcr = async(strOcr) => {
        let wordsResult = [];
        //特殊处理 字符串包含 双引号"
        if(strOcr.indexOf(", ('") != -1)
            strOcr = strOcr.replace(/"/g, '\\\"');

        let arrOcr = strOcr.split(")]");
        let strTemp, index;

        for(let i = 0; i < arrOcr.length - 1; i++){
            strTemp = arrOcr[i].replace(/\[/, '{"location":');
            strTemp = strTemp.replace(/\, \('/, ',"words":"');
            strTemp = strTemp.replace(/\, \("/, ',"words":"');//特殊处理 字符串包含 单引号'
            index = strTemp.lastIndexOf("', ");
            //特殊处理 字符串包含 单引号'
            if(index == -1)
                index = strTemp.lastIndexOf("\", ");

            strTemp = strTemp.substring(0, index) + "\"}";
            wordsResult[i] = JSON.parse(strTemp);
        }
        
        return wordsResult;
    }

    /**ocr
     * @param {string|number} hwnd  窗口句柄
     * @param {left:number} left 左上角x点
     * @param {top:number} top 左上角y点
     * @param {right:number} right 右下角 x点
     * @param {bottom:number} bottom 右下角 y点
     * @param {mode:boolean} mode 操作模式，后台 true，前台 false。默认前台操作   
     * @return {Promise.<[]>} 失败返回null，成功返回数组形式的识别结果
    */
    ocr = async (hwnd, left, top, right, bottom, mode = false) =>{
        let strData = this.setSendData("ocr", hwnd, left, top, right, bottom, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null" || strRet == "")
            return null;
        else
            return this.splitOcr(strRet);
    }

    /**ocrByFile
     * @param {string} imagePath 图片路径
     * @param {left:number} left 左上角x点
     * @param {top:number} top 左上角y点
     * @param {right:number} right 右下角 x点
     * @param {bottom:number} bottom 右下角 y点
     * @return {Promise.<[]>} 失败返回null，成功返回数组形式的识别结果
    */
     ocrByFile = async (imagePath, left, top, right, bottom) =>{
        let strData = this.setSendData("ocrByFile", imagePath, left, top, right, bottom);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null" || strRet == "")
            return null;
        else
            return this.splitOcr(strRet);
    }

    /**获取屏幕文字
     * @param {string|number} hwndOrImagePath  窗口句柄或者图片路径
     * @param {{region:[left:number, top:number, right:number, bottom:number], mode:boolean}} options 可选参数
     * region 指定区域 [10, 20, 100, 200]，region默认全图
     * mode 操作模式，后台 true，前台 false。默认前台操作, 仅适用于hwnd
     * @return {Promise.<string>} 失败返回null，成功返窗口上的文字
    */
    async getWords(hwndOrImagePath, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }

        let wordsResult;
        if(hwndOrImagePath.indexOf(".") == -1){
            let mode = false;
            if(options["mode"] != undefined)
                mode = options["mode"];
            wordsResult = await this.ocr(hwndOrImagePath, left, top, right, bottom, mode);
        }
        else
            wordsResult = await this.ocrByFile(hwndOrImagePath, left, top, right, bottom);
        
        if(wordsResult == null)
            return null;
        
        let words = "";
        let i;
        for(i = 0; i < wordsResult.length - 1; i++)
            words += wordsResult[i].words + "\n";
        words += wordsResult[i].words

        return words;
    }

    /**查找文字
     * @param {string|number} hwndOrImagePath  窗口句柄或者图片路径
     * @param {string} words 要查找的文字
     * @param {{region:[left:number, top:number, right:number, bottom:number], mode:boolean}} options 可选参数
     * region 指定区域 [10, 20, 100, 200]，region默认全图
     * mode 操作模式，后台 true，前台 false。默认前台操作, 仅适用于hwnd
     * @return {Promise.<[{x:number, y:number}]>} 失败返回null，成功返回数组[{x:number, y:number}, ...]，文字所在的坐标点
    */
    async findWords(hwndOrImagePath, words, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }

        let wordsResult;
        if(hwndOrImagePath.indexOf(".") == -1){
            let mode = false;
            if(options["mode"] != undefined)
                mode = options["mode"];
            wordsResult = await this.ocr(hwndOrImagePath, left, top, right, bottom, mode);
        }
        else
            wordsResult = await this.ocrByFile(hwndOrImagePath, left, top, right, bottom);
            
        if(wordsResult == null)
            return null;

        let points = [];
        let localLeft, localTop, localRight, localBottom, width, height;
        let wordWidth, index, offsetX, offsetY, x, y;
        for(let i = 0, j = 0; i < wordsResult.length; i++){
            index = wordsResult[i].words.indexOf(words);
            if(index != -1){
                localLeft = wordsResult[i].location[0][0];
                localTop = wordsResult[i].location[0][1];
                localRight = wordsResult[i].location[2][0];
                localBottom = wordsResult[i].location[2][1];
                width = localRight - localLeft;
                height = localBottom - localTop;

                wordWidth = width / wordsResult[i].words.length;
                offsetX = wordWidth * (index + words.length / 2);
                offsetY = height / 2;
                x = parseInt(localLeft + offsetX + left);
                y = parseInt(localTop + offsetY + top);
                points[j] = {"x":x, "y":y};
                j++;
            }
        }
        
        if(points.length == 0)
            return null;
        else    
            return points;
    }
    
    /**获取指定元素名称
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @return {Promise.<string>} 成功返回元素名称
    */
    async getElementName(hwnd, xpath){
        let strData = this.setSendData('getElementName', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "null")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**获取指定元素文本
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @return {Promise.<string>} 成功返回元素文本
    */
    async getElementValue(hwnd, xpath){
        let strData = this.setSendData('getElementValue', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "null")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**获取指定元素矩形大小
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @return {Promise.<{left:number, top:number, right:number, bottom:number}>} 成功返回元素位置，失败返回null
    */
    async getElementRect(hwnd, xpath){
        let strData = this.setSendData('getElementRect', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "-1|-1|-1|-1")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "-1|-1|-1|-1")
            return null;
        let arrRet = strRet.split("|");
        return {left: parseInt(arrRet[0]), top: parseInt(arrRet[1]), right: parseInt(arrRet[2]), bottom: parseInt(arrRet[3])};
    }

    /**获取元素窗口句柄
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @return {Promise.<string>} 成功返回元素窗口句柄，失败返回null
    */
     async getElementWindow(hwnd, xpath){
        let strData = this.setSendData('getElementWindow', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "null")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**点击元素
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @param {number} msg 单击左键:1 单击右键:2 按下左键:3 弹起左键:4 按下右键:5 弹起右键:6 双击左键:7 双击右键:8
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async clickElement(hwnd, xpath, msg){
        let strData = this.setSendData('clickElement', hwnd, xpath, msg);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置指定元素作为焦点
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setElementFocus(hwnd, xpath){
        let strData = this.setSendData('setElementFocus', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置元素文本
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @param {string} value 要设置的内容
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setElementValue(hwnd, xpath, value){
        let strData = this.setSendData('setElementValue', hwnd, xpath, value);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**滚动元素
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @param {number} horizontalPercent 水平百分比 -1不滚动
     * @param {number} verticalPercent 垂直百分比 -1不滚动
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
     async setElementScroll(hwnd, xpath, horizontalPercent, verticalPercent){
        let strData = this.setSendData('setElementScroll', hwnd, xpath, horizontalPercent, verticalPercent);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**单/复选框是否选中
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async isSelected(hwnd, xpath){
        let strData = this.setSendData('isSelected', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "selected")
            return true;
        else
            return false;
    }

    /**关闭窗口
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async closeWindow(hwnd, xpath){
        let strData = this.setSendData('closeWindow', hwnd, xpath);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置窗口状态
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @param {number} state 0正常 1最大化 2 最小化
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setWindowState(hwnd, xpath, state){
        let strData = this.setSendData('setWindowState', hwnd, xpath, state);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置剪切板文本
     * @param {string} text 设置的文本
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setClipboardText(text){
        let strData = this.setSendData('setClipboardText', text);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**获取剪切板文本
     * @return {Promise.<string>} 返回剪切板文本
    */
    async getClipboardText(){
        let strData = this.setSendData('getClipboardText');
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return strRet;
    }

    /**启动指定程序
     * @param {string} commandLine 启动命令行
     * @param {boolean} showWindow 是否显示窗口。可选参数,默认显示窗口
     * @param {boolean} isWait 是否等待程序结束。可选参数,默认不等待
     * @return {Promise.<boolean>} 成功返回true,失败返回false
    */
    async startProcess(commandLine, showWindow = true, isWait = false){
        let strData = this.setSendData('startProcess', commandLine, showWindow, isWait);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**执行cmd命令
     * @param {string} command cmd命令，不能含 "cmd"字串
     * @param {number} waitTimeout 可选参数，等待结果返回超时，单位毫秒，默认300毫秒
     * @return {Promise.<string>} 返回cmd执行结果
    */
    async executeCommand(command, waitTimeout = 300){
        let strData = this.setSendData('executeCommand', command, waitTimeout);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return strRet;
    }

    /**指定url下载文件
     * @param {string} url 文件地址
     * @param {string} filePath 文件保存的路径
     * @param {boolean} isWait 是否等待.为true时,等待下载完成
     * @return {Promise.<boolean>} 总是返回true
    */
    async downloadFile(url, filePath, isWait){
        let strData = this.setSendData('downloadFile', url, filePath, isWait);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**打开excel文档
     * @param {string} excelPath excle路径
     * @return {Promise.<Object>} 成功返回excel对象，失败返回null
    */
    async openExcel(excelPath){
        let strData = this.setSendData('openExcel', excelPath);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return JSON.parse(strRet);
    }

    /**打开excel表格
     * @param {Object} excelObject excel对象
     * @param {string} sheetName 表名
     * @return {Promise.<Object>} 成功返回sheet对象，失败返回null
    */
    async openExcelSheet(excelObject, sheetName){
        let strData = this.setSendData('openExcelSheet', excelObject['book'], excelObject['path'], sheetName);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**保存excel文档
     * @param {Object} excelObject excel对象
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async saveExcel(excelObject){
        let strData = this.setSendData('saveExcel', excelObject['book'], excelObject['path']);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**写入数字到excel表格
     * @param {Object} sheetObject sheet对象
     * @param {number} row 行
     * @param {number} col 列
     * @param {number} value 写入的值
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async writeExcelNum(sheetObject, row, col, value){
        let strData = this.setSendData('writeExcelNum', sheetObject, row, col, value);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**写入字符串到excel表格
     * @param {Object} sheetObject sheet对象
     * @param {number} row 行
     * @param {number} col 列
     * @param {string} strValue 写入的值
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async writeExcelStr(sheetObject, row, col, strValue){
        let strData = this.setSendData('writeExcelStr', sheetObject, row, col, strValue);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**读取excel表格数字
     * @param {Object} sheetObject sheet对象
     * @param {number} row 行
     * @param {number} col 列
     * @return {Promise.<number>} 返回读取到的数字
    */
    async readExcelNum(sheetObject, row, col){
        let strData = this.setSendData('readExcelNum', sheetObject, row, col);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return parseFloat(strRet);
    }

    /**读取excel表格字串
     * @param {Object} sheetObject sheet对象
     * @param {number} row 行
     * @param {number} col 列
     * @return {Promise.<string>} 返回读取到的字符
    */
    async readExcelStr(sheetObject, row, col){
        let strData = this.setSendData('readExcelStr', sheetObject, row, col);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return strRet;
    }

    /**删除excel表格行
     * @param {Object} sheetObject sheet对象
     * @param {number} rowFirst 起始行
     * @param {number} rowLast 结束行
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async removeExcelRow(sheetObject, rowFirst, rowLast){
        let strData = this.setSendData('removeExcelRow', sheetObject, rowFirst, rowLast);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**删除excel表格列
     * @param {Object} sheetObject sheet对象
     * @param {number} colFirst 起始列
     * @param {number} colLast 结束列
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async removeExcelCol(sheetObject, colFirst, colLast){
        let strData = this.setSendData('removeExcelCol', sheetObject, colFirst, colLast);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**识别验证码
    * @param {string} filePath 图片文件路径
    * @param {string} username 用户名
    * @param {string} password 密码
    * @param {string} softId 软件ID
    * @param {string} codeType 图片类型 参考https://www.chaojiying.com/price.html
    * @param {string} lenMin 最小位数 默认0为不启用,图片类型为可变位长时可启用这个参数
    * @return {Promise.<{err_no:number, err_str:string, pic_id:string, pic_str:string, md5:string}>} 返回JSON
    * err_no,(数值) 返回代码  为0 表示正常，错误代码 参考https://www.chaojiying.com/api-23.html
    * err_str,(字符串) 中文描述的返回信息 
    * pic_id,(字符串) 图片标识号，或图片id号
    * pic_str,(字符串) 识别出的结果
    * md5,(字符串) md5校验值,用来校验此条数据返回是否真实有效
    */
    async getCaptcha(filePath, username, password, softId, codeType, lenMin = 0){
        let fileBase64 = await fs.readFileSync(filePath, 'base64');
        return new Promise((resolve) => {
            restler.post('http://upload.chaojiying.net/Upload/Processing.php', {
                multipart: true,
                data: {
                    'user': username,
                    'pass': password,
                    'softid':softId, 
                    'codetype': codeType,
                    'len_min':lenMin,
                    'file_base64': fileBase64
                },
                headers: { 
                    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:24.0) Gecko/20100101 Firefox/24.0',
                    'Content-Type' : 'application/x-www-form-urlencoded' 
                }
            }).on('complete', function(data) {
                resolve(data);
            });
        });
    }

    /**识别报错返分
    * @param {string} username 用户名
    * @param {string} password 密码
    * @param {string} softId 软件ID
    * @param {string} picId 图片ID 对应 getCaptcha返回值的pic_id 字段
    * @return {Promise.<{err_no:number, err_str:string}>} 返回JSON
    * err_no,(数值) 返回代码
    * err_str,(字符串) 中文描述的返回信息
    */
    async errorCaptcha(username, password, softId, picId){
        return new Promise((resolve) => {
            restler.post('http://upload.chaojiying.net/Upload/ReportError.php', {
                multipart: true,
                data: {
                    'user': username,
                    'pass': password,
                    'softid':softId, 
                    'id': picId,
                },
                headers: { 
                    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:24.0) Gecko/20100101 Firefox/24.0',
                    'Content-Type' : 'application/x-www-form-urlencoded' 
                }
            }).on('complete', function(data) {
                resolve(data);
            });
        });
    }

    /**查询验证码剩余题分
    * @param {string} username 用户名
    * @param {string} password 密码
    * @return {Promise.<{err_no:number, err_str:string, tifen:string, tifen_lock:string}>} 返回JSON
    * err_no,(数值) 返回代码
    * err_str,(字符串) 中文描述的返回信息
    * tifen,(数值) 题分
    * tifen_lock,(数值) 锁定题分
    */
    async scoreCaptcha(username, password){
        return new Promise((resolve) => {
            restler.post('http://upload.chaojiying.net/Upload/GetScore.php', {
                multipart: true,
                data: {
                    'user': username,
                    'pass': password,
                },
                headers: { 
                    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:24.0) Gecko/20100101 Firefox/24.0',
                    'Content-Type' : 'application/x-www-form-urlencoded' 
                }
            }).on('complete', function(data) {
                resolve(data);
            });
        });
    }
}

class Mutex {
    constructor () {
        this.queue = [];
        this.locked = false;
    }

    lock () {
        return new Promise((resolve, reject) => {
            if (this.locked) {
                this.queue.push([resolve, reject]);
            } else {
                this.locked = true;
                resolve();
            }
        });
    }

    release () {
        if (this.queue.length > 0) {
            const [resolve, reject] = this.queue.shift();
            resolve();
        } else {
            this.locked = false;
        }
    }
}

module.exports = WindowsBot;